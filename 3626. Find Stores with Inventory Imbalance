Problem:

Table: stores

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| store_id    | int     |
| store_name  | varchar |
| location    | varchar |
+-------------+---------+
store_id is the unique identifier for this table.
Each row contains information about a store and its location.
Table: inventory

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| inventory_id| int     |
| store_id    | int     |
| product_name| varchar |
| quantity    | int     |
| price       | decimal |
+-------------+---------+
inventory_id is the unique identifier for this table.
Each row represents the inventory of a specific product at a specific store.
Write a solution to find stores that have inventory imbalance - stores where the most expensive product has lower stock than the cheapest product.

For each store, identify the most expensive product (highest price) and its quantity
For each store, identify the cheapest product (lowest price) and its quantity
A store has inventory imbalance if the most expensive product's quantity is less than the cheapest product's quantity
Calculate the imbalance ratio as (cheapest_quantity / most_expensive_quantity)
Round the imbalance ratio to 2 decimal places
Only include stores that have at least 3 different products
Return the result table ordered by imbalance ratio in descending order, then by store name in ascending order.

Solution:

WITH ProductStats AS (
    -- Step 1: Identify price rankings and count total products per store
    SELECT 
        store_id,
        product_name,
        quantity,
        price,
        RANK() OVER(PARTITION BY store_id ORDER BY price DESC) as expensive_rank,
        RANK() OVER(PARTITION BY store_id ORDER BY price ASC) as cheapest_rank,
        COUNT(*) OVER(PARTITION BY store_id) as product_count
    FROM inventory
),
Extremes AS (
    -- Step 2: Extract the top expensive and cheapest products into one row per store
    SELECT 
        store_id,
        MAX(CASE WHEN expensive_rank = 1 THEN product_name END) as most_exp_product,
        MAX(CASE WHEN expensive_rank = 1 THEN quantity END) as most_exp_qty,
        MAX(CASE WHEN cheapest_rank = 1 THEN product_name END) as cheapest_product,
        MAX(CASE WHEN cheapest_rank = 1 THEN quantity END) as cheapest_qty
    FROM ProductStats
    WHERE product_count >= 3
    GROUP BY store_id
)
-- Step 3: Join with stores table and filter for inventory imbalance
SELECT 
    s.store_id,
    s.store_name,
    s.location,
    e.most_exp_product,
    e.cheapest_product,
    ROUND(e.cheapest_qty / e.most_exp_qty, 2) as imbalance_ratio
FROM stores s
JOIN Extremes e ON s.store_id = e.store_id
WHERE e.most_exp_qty < e.cheapest_qty
ORDER BY imbalance_ratio DESC, s.store_name ASC;
